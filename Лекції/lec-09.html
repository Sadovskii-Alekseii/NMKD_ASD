<!DOCTYPE html>
<html>
<head>
	<title>АСД. Лекція № 9</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">АСД. Лекція № 9</div>
		<ul class="lec-menu"> 
			<li><a href="index.html">Зміст</a></li> 
			<li><a href="lec-01.html">01</a></li> 
			<li><a href="lec-02.html">02</a></li> 
			<li><a href="lec-03.html">03</a></li> 
			<li><a href="lec-04.html">04</a></li> 
			<li><a href="lec-05.html">05</a></li> 
			<li><a href="lec-06.html">06</a></li> 
			<li><a href="lec-07.html">07</a></li> 
			<li><a href="lec-08.html">08</a></li> 
			<li><a href="lec-09.html">09</a></li> 
			<li><a href="lec-10.html">10</a></li> 
		</ul> 
		<h1>Алгоритми пошуку</h1>




		<p>
			Одна з
			тих дій, які найбільш часто зустрічаються в програмуванні - пошук. Існує
			декілька основних варіантів пошуку, і для них створено багато різноманітних
			алгоритмів.
		</p>

		<p>
			Задача пошуку - відшукати елемент, ключ якого рівний заданому
			„аргументу пошуку”. Отриманий в результаті цього індекс забезпечує доступ до
			усіх полів виявленого елемента.
		</p>

		<p>
			9.1.


			Послідовний (лінійний) пошук
		</p>

		<p>
			Найпростішим
			методом пошуку елемента, який знаходиться в неврегульованому наборі даних, за
			значенням його ключа є послідовний перегляд кожного елемента набору, який
			продовжується до тих пір, поки не буде знайдений потрібний елемент. Якщо
			переглянуто весь набір, і елемент не знайдений - значить, шуканий ключ
			відсутній в наборі. Цей метод ще називають методом повного перебору.
		</p>

		<p>
			Для
			послідовного пошуку в середньому потрібно <i>N/2</i> порівнянь. Таким чином,
			порядок алгоритму - лінійний - <i>O(N).</i> Якщо елемент знайдено, то він
			знайдений разом з мінімально можливим індексом, тобто це перший з таких
			елементів. Рівність <i>i=N</i> засвідчує, що елемент відсутній.
		</p>

		<p>
			Єдина модифікація цього алгоритму, яку можна зробити, - позбавитися
			перевірки номера елементу масиву в заголовку циклу (<i>i&lt;N</i>) за рахунок
			збільшення масиву на один елемент у кінці, значення якого перед пошуком
			встановлюють рівним шуканому ключу - <i>key</i> - так званий „бар’єр”.
		</p>

		<p>
			9.2.


			Бінарний пошук
		</p>

		<p>
			Алгоритм пошук може бути значно ефективнішим, якщо дані будуть
			впорядковані.
			
		</p>

		<p>
			Іншим,
			відносно простим, методом доступу до елемента є метод бінарного (дихотомічного)
			пошуку, який виконується в явно впорядкованій послідовності елементів.
		</p>

		<p>
			>Оскільки шуканий елемент швидше за все знаходиться „десь в середині”,
			перевіряють саме середній елемент: <i>a[N/2]==key?</i> Якщо це так, то знайдено
			те, що потрібно. Якщо <i>a[N/2]&lt;key,</i> то значення <i>i=N/2</i> є замалим
			і шуканий елемент знаходиться „праворуч”, а якщо <i>a[N/2]&gt;key,</i> то
			„ліворуч”, тобто на позиціях <i>0...І.</i>
		</p>

		<p>
			Для
			того, щоб знайти потрібний запис в таблиці, у гіршому випадку потрібно <i>log2(N)</i>
			порівнянь. Це значно краще, ніж при послідовному пошуку.
		</p>

		<p>
			Максимальна
			кількість порівнянь для цього алгоритму рівна <i>log2(N).</i> Таким чином,
			приведений алгоритм суттєво виграє у порівнянні з лінійним пошуком.
		</p>

		<p>
			Відомо декілька модифікацій алгоритму бінарного пошуку, які виконуються
			на деревах.
		</p>

		<p>
			9.3. 


			Метод інтерполяції
		</p>

		<p>
			<img src="img/05-027.jpg" v:shapes="Shape_x0020_39" width="276" vspace="1" hspace="11" height="166" align="right">Якщо немає ніякої додаткової
			інформації про значення ключів, крім факту їхнього впорядкування, то можна
			припустити, що значення <i>key</i> збільшуються від <i>a[0]</i> до <i>a[N-1] </i>більш-менш
			„рівномірно”. Це означає, що значення середнього елементу <i>a[N/2]</i> буде
			близьким до середнього арифметичного між найбільшим та найменшим значенням.
			Але, якщо шукане значення <i>key</i> відрізняється від вказаного, то є деякий
			сенс для перевірки брати не середній елемент, а „середньо- пропорційний”.
		</p>

		<p>
			Вираз
			для поточного значення <i>i</i> одержано з пропорційності відрізків:
		</p>

		<p>
			<i>a[e]-key _e- i</i>
		</p>

		<p>
			<i>key - a[b] i - b</i>
		</p>

		<p>
			В середньому цей алгоритм має працювати швидше за бінарний пошук, але у
			найгіршому випадку буде працювати набагато довше.
		</p>

		<p>
			9.4.


			Метод „золотого перерізу”
		</p>

		<p>
			Деякий ефект дає використання так званого „золотого перерізу”. Це число
			<i>ф,</i>
		</p>

		<p>
			що має
			властивість:
		</p>

		<p>
			, 1 <sub>2</sub> , <sub>Л</sub>
		</p>

		<p>
			<img src="img/05-028.gif" alt="Подпись: 1 ±^5
			2
			" v:shapes="Shape_x0020_41" width="56" height="56" align="right">
			<table cellspacing="0" cellpadding="0">
				<tbody><tr>
					<td width="49" height="0"></td>
				</tr>
				<tr>
					<td></td>
					<td><img src="img/05-029.gif" v:shapes="Shape_x0020_43 Shape_x0020_45 Shape_x0020_47" width="562" height="55"></td>
				</tr>
			</tbody></table>
			
			<i>ф-1 = -; ф-ф-1 = 0; ф^
			=</i>
		</p>

		<p>
			Згідно цього алгоритму відрізок слід ділити не навпіл, як у бінарному
			алгоритмі, а на відрізки, пропорційні <i>ф</i> та 1, в залежності від
			того, до якого краю ближче <i>key</i>.
		</p>

		<p>
			9.5.


			Алгоритми пошуку послідовностей
		</p>

		<p>
			Даний
			клас задача відноситься до задачі пошуку слів у тексті. Одним з найпростіших
			методів пошуку є послідовне порівняння першого символу з символами масиву. Якщо
			наявний збіг, тоді порівнюються другі, треті,... символи аж до повного збігу
			рядка <i>5</i> з частиною вектору такої ж довжини, або до незбігу у деякому
			символі. Тоді пошук продовжується з наступного символу масиву та першого
			символу рядку.
		</p>

		<p>
			Існує
			варіант удосконалення цього алгоритму - це починати пошук після часткового
			збігу не з наступного елементу масиву, а з символу, наступного після тих, що
			переглядалися, якщо у рядку немає фрагментів, що повторюються.
		</p>

		<p>
			Д.
			Кнут, Д. Моріс і В. Пратт винайшли алгоритм, який фактично потребує лише <i>N</i>
			порівнянь навіть в самому поганому випадку. Новий алгоритм базується на тому,
			що після часткового збігу початкової частини слова з відповідними символами
			тексту фактично відома пройдена частина тексту і можна „обчислити” деякі
			відомості (на основі самого слова), за допомогою яких потім можна швидко
			переміститися текстом.
		</p>

		<p>
			Основною
			відмінністю КМП-алгоритму від алгоритму прямого пошуку є здійснення зсуву слова
			не на один символ на кожному кроці алгоритму, а на деяку змінну кількість
			символів. Таким чином, перед тим як виконувати черговий зсув, потрібно
			визначити величину зсуву. Для підвищення ефективності алгоритму необхідно, щоб
			зсув на кожному кроці був би якомога більшим.
		</p>

		<p>
			Якщо <i>j</i>
			визначає позицію в слові, в якій міститься перший символ, який не збігається
			(як в алгоритмі прямого пошуку), то величина зсуву визначається як <i>j-D. </i>Значення
			<i>D</i> визначається як розмір самої довшої послідовності символів слова, які
			безпосередньо передують позиції <i>j</i>, яка повністю збігається з початком
			слова. <i>D </i>залежить тільки від слова і не залежить від тексту. Для кожного
			<i>j</i> буде своя величина <i>D</i>, яку позначимо <i>dj.</i>
		</p>

		<p>
			Так як
			величини <i>dj</i> залежать лише від слова, то перед початком фактичного пошуку можна
			обчислити допоміжну таблицю <i>d</i>; ці обчислення зводяться до деякої
			попередньої трансляції слова. Відповідні зусилля будуть оправдані, якщо розмір
			тексту значно перевищує розмір слова <i>(M&lt;&lt;N).</i> Якщо потрібно шукати
			багатократні входження одного й того ж слова, то можна користуватися одними й
			тими ж <i>d.</i>
		</p>

		<p>
			КМП<i>-</i>пошук
			дає справжній виграш тільки тоді, коли невдачі передувала деяка кількість
			збігів. Лише у цьому випадку слово зсовується більше ніж на одиницю. На жаль,
			це швидше виняток, ніж правило: збіги зустрічаються значно рідше, ніж незбіги.
			Тому виграш від практичного використання КМП<i>-</i>стратегії в більшості
			випадків пошуку в звичайних текстах досить незначний. Метод, який запропонували
			Р. Боуєр і Д. Мур в 1975 р., не тільки покращує обробку самого поганого
			випадку, але й дає виграш в проміжних ситуаціях.
		</p>

		<p>
			БМ<i>-</i>пошук
			базується на незвичних міркуваннях - порівняння символів починається з кінця
			слова, а не з початку. Як і у випадку КМП<i>-</i>пошуку, слово перед фактичним
			пошуком трансформується в деяку таблицю. Нехай для кожного символу <i>x</i> із
			алфавіту величина <i>dx</i> - відстань від самого правого в слові входження <i>x</i>
			до правого кінця слова. Уявимо, що виявлена розбіжність між словом і текстом. У
			цьому випадку слово відразу ж можна зсунути праворуч на <i>dpM-1</i> позицій,
			тобто на кількість позицій, швидше за все більше одиниці. Якщо символ, який не
			збігся, тексту в слові взагалі не зустрічається, то зсув стає навіть більшим, а
			саме зсовувати можна на довжину всього слова.
		</p>

		<p>
			Варто сказати, що запропоновані методи пошуку послідовностей можна
			модифікувати таким чином, щоб у кожному рядку пошук йшов не до кінця кожного
			рядка, а на кількість шуканих символів менше, бо слово <i>5</i> не може бути
			розташоване у кінці одного рядка та на початку наступного.
		</p>

	</div>
</body>
</html>