<!DOCTYPE html>
<html>
<head>
	<title> Лекція № 4</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Лекція № 4</div>
		<h1>Динамічні структури даних. Списки</h1>



4.<span style="font:7.0pt &quot;Times New Roman&quot;"> 
<!--[endif]--> НАПІВСТАТИЧНІ СТРУКТУРИ ДАНИХ</p>

<h2>Характерні особливості напівстатичних структур</h2>

<p>Напівстатичні
структури даних характеризуються наступними ознаками:</p>
<ol>
	<li>
		вони мають змінну довжину і прості процедури її зміни;
	</li>
	<li>
		зміна довжини структури відбувається в певних межах, не перевищуючи якогось максимального (граничного) значення.
	</li>
</ol>




<p>Якщо напівстатичну структуру розглядати на логічному рівні, то це
послідовність даних, зв’язана відносинами лінійного списку. Доступ до елемента
може здійснюватися за його порядковим номером.</p>

<p>Фізичне представлення напівстатичних структур даних в пам’яті - це
звичайно послідовність комірок в пам’яті, де кожний наступний елемент
розташований в пам’яті в наступній комірці. Фізичне представлення може мати
також вид одно-направленого зв’язного списку (ланцюжки), де кожний наступний
елемент адресується покажчиком, який знаходиться в поточному елементі. У цьому
випадку обмеження на довжину структури менш строгі.</p>

<h2>Стеки</h2>

<p>Стеком
називається множина деякої змінної кількості даних, над якою виконуються
наступні операції:</p>

<ol>
	<li>Поповнення стеку новими даними;</li>
	<li>Перевірка, яка визначає чи стек
пустий;</li>
	<li>Перегляд останніх добавлених
даних;</li>
	<li>Знищення останніх добавлених
даних.</li>
</ol>


<p>На
основі такого функціонального опису, можна сформувати логічний опис. Стек - це
такий послідовний список із змінній довжиною, включення і виключення елементів
з якого виконуються тільки з одного боку списку. Застосовуються і інші назви
стеку - магазин, пам’ять що функціонує за принципом LIFO (Last - In - First -
Out - „останнім прийшов - першим вийшов”).</p>

<p>Самий
„верхній” елемент стеку, тобто останній добавлений і ще не знищений, відіграє
особливу роль: саме його можна модифікувати й знищувати. Цей елемент називають
вершиною стеку. Іншу частину стеку називають тілом стеку. Тіло стеку, само
собою, є стеком: якщо виключити зі стеку його вершину, то тіло перетворюється в
стек.</p>

<p>Основні
операції над стеком - включення нового елемента (<b>push </b>- заштовхувати) і
виключення елемента зі стеку (<b>pop </b>- вискакувати).</p>

<p>Корисними
можуть бути також допоміжні операції:</p>

<ol>
	<li>визначення поточної кількості
елементів в стеку;</li>
	<li>очищення стеку;</li>
	<li>„неруйнуюче” читання елемента з
вершини стека, яке може бути реалізоване, як комбінація основних операцій -
виключити елемент зі стеку та включити його знову в стек.</li>
</ol>



<p>При
представленні стеку в статичній пам’яті для стеку виділяється пам’ять, як для
вектора. В описі цього вектора окрім звичайних для вектора параметрів повинен
знаходитися також покажчик стеку - адреса вершини стека. Обмеження даного
представлення полягає в тому, що розмір стеку обмежений розмірами вектора.</p>

<p>Покажчик
стеку може вказувати або на перший вільний елемент стеку, або на останній
записаний в стек елемент. Однаково, який з цих двох варіантів вибрати, важливо
надалі строго дотримуватися його при обробці стеку.</p>

<p>При
занесенні елементу в стек елемент записується на місце, яке визначається
покажчиком стеку, потім покажчик модифікується так, щоб він вказував на
наступний вільний елемент (якщо покажчик вказує на останній записаний елемент,
то спочатку модифікується покажчик, а потім проводиться запис елемента).
Модифікація покажчика полягає в надбавці до нього або у відніманні від нього
одиниці (стек росте у бік збільшення адреси).</p>

<p>Операція
виключення елемента полягає в модифікації покажчика стеку (в напрямку,
зворотному модифікації при включенні) і вибірці значення, на яке вказує
покажчик стеку. Після вибірки комірка, в якій розміщувався вибраний елемент,
вважається вільною.</p>

<p>Операція
очищення стеку зводиться до запису в покажчик стеку початкового значення -
адреси початку виділеної ділянки пам’яті.</p>

<p>Визначення
розміру стека зводиться до обчислення різниці покажчиків: покажчика стеку й
адреси початку ділянки.</p>

<p>При
зв’язному представленні стеку кожен елемент стеку складається із значення і
покажчика, який вказує на попередньо занесений у стек елемент. Зв’язне
представлення викликає втрату пам’яті, що викликане наявністю покажчика в
кожному елементі стеку, і представляє інтерес тільки у випадку, коли важко
визначити максимальний розмір стеку.</p>

<p>Отже,
для зв’язного представлення стеку потрібно, щоб кожен його елемент описувався
структурою, яка поєднує дані і покажчик на наступний елемент.</p>

<p>Для
виконання операцій над стеком потрібен один покажчик на вершину стеку.
Створення пустого стеку полягатиме у присвоєнні покажчику на вершину нульового
значення, що означатиме, що стек пустий.</p>

<p>Послідовність
кроків для добавлення елементу в стек складається з декількох кроків:</p>

<ol>
	<li>Виділити пам’ять під новий елемент
стеку;</li>
	<li>Занесення значення в інформаційне
поле;</li>
	<li>Встановлення зв’язку між ним і
„старою” вершиною стеку;</li>
	<li>Переміщення вершини стеку на новий
елемент.</li>

</ol>


<p>Вилучення
елементу зі стеку також проводять за кілька кроків:</p>

<ol>
	<li>Зчитування інформації з
інформаційного поля вершини стеку;</li>
	<li>Встановлення на вершину стеку
допоміжного покажчика;</li>
	<li>Переміщення покажчика вершини
стеку на наступний елемент;</li>
	<li>Звільнення пам’яті, яку займає
„стара” вершина стеку.</li>
</ol>

<h2>Черга</h2>

<p>Чергою
називається множина змінної кількості даних, над якою можна виконувати наступні
операції:</p>
<ol>
	<li>Поповнення черги новими даними;</li>
	<li>Перевірка, яка визначає чи пуста
черга;</li>
	<li>Перегляд перших добавлених даних;</li>
	<li>Знищення самих перших добавлених
даних.</li>

</ol>

<p>На
основі такого функціонального опису, можна сформувати логічний опис. Чергою
FIFO (First - In - First - Out - „першим прийшов - першим вийшов”). називається
такий послідовний список із змінній довжиною, в якому включення елементів
виконується тільки з одного боку списку (хвіст черги), а виключення - з другого
боку (голова черги).</p>

<p>Основні
операції над чергою - ті ж, що і над стеком - включення, виключення, визначення
розміру, очищення, „неруйнуюче” читання.</p>

<p>При
представленні черги вектором в статичній пам’яті на додаток до звичайних для
опису вектора параметрів в ньому повинні знаходитися два покажчики: на голову і
на хвіст черги. При включенні елемента в чергу елемент записується за адресою,
яка визначається покажчиком на хвіст, після чого цей покажчик збільшується на
одиницю. При виключенні елемента з черги вибирається елемент, що адресується
покажчиком на голову, після чого цей покажчик зменшується на одиницю.</p>

<p>Очевидно,
що з часом покажчик на хвіст при черговому включенні елемента досягне верхньої
межі тієї ділянки пам’яті, яка виділена для черги. Проте, якщо операції
включення чергувати з операціями виключення елементів, то в початковій частині
відведеної під чергу пам’яті є вільне місце. Для того, щоб місця, займані
виключеними елементами, могли бути повторно використані, черга замикається в
кільце: покажчики (на початок і на кінець), досягнувши кінця виділеної області
пам’яті, перемикаються на її початок. Така організація черги в пам’яті
називається кільцевою чергою. Можливі, звичайно, і інші варіанти організації:
наприклад, всякий раз, коли покажчик кінця досягне верхньої межі пам’яті, зсовувати
всі не порожні елементи черги до початку ділянки пам’яті, але як цей, так і
інші варіанти вимагають переміщення в пам’яті елементів черги і менш ефективні,
ніж кільцева черга.</p>

<p>У
початковому стані покажчики на голову і хвіст вказують на початок ділянки
пам’яті. Рівність цих двох покажчиків є ознакою порожньої черги. Якщо в процесі
роботи з кільцевою чергою кількість операцій включення перевищує кількість
операцій виключення, то може виникнути ситуація, в якій покажчик кінця
„наздожене” покажчик початку. Це ситуація заповненої черги, але якщо в цій
ситуації покажчики порівняються, ця ситуація буде така ж як при порожній черзі.
Для розрізнення цих двох ситуацій до кільцевої черги пред’являється вимога, щоб
між покажчиком кінця і покажчиком початку залишався „проміжок” з вільних
елементів. Коли цей „проміжок” скорочується до одного елемента, черга
вважається заповненою і подальші спроби запису в неї блокуються. Очищення черги
зводиться до запису одного і того ж (не обов’язково початкового) значення в
обидва покажчики. Визначення розміру полягає в обчисленні різниці покажчиків з
урахуванням кільцевої природи черги.</p>

<p>При
зв’язному представленні черги кожен елемент черги складається із значення і
покажчика, який вказує на попередньо занесений у чергу елемент.</p>

<p>Зв’язне
представлення викликає втрату пам’яті, що викликане наявністю покажчика в
кожному елементі черги, і представляє інтерес тільки у випадку, коли важко
визначити максимальний розмір черги. Для зв’язного представлення черги
потрібно, щоб кожен його елемент описувався структурою, яка поєднує дані і
покажчик на наступний елемент.</p>

<p>Для
виконання операцій над чергою потрібно два покажчики: на голову і хвіст черги.
Створення пустої черги полягатиме у присвоєнні покажчикам на голову і хвіст
черги нульових значень, що означатиме, що черга пуста.</p>

<p>Послідовність
кроків для добавлення елемента в кінець черги складається з декількох кроків:</p>

<ol>
	<li>Виділити пам’ять під новий елемент
черги;</li>
	<li>Занесення значення в інформаційне
поле;</li>
	<li>Занесення нульового значення в
покажчик;</li>
	<li>Встановлення зв’язку між ним і
останнім елементом черги і новим, враховуючи випадок пустої черги;</li>
<li>Переміщення покажчика кінця черги
на новий елемент.</li>
</ol>


<p>Вилучення
елементу з черги також проводять за кілька кроків:</p>

<ol>
	<li>Зчитування інформації з інформаційного поля голови черги;</li>
	<li>Встановлення на голову черги допоміжного покажчика;</li>
	<li>Переміщення покажчика початку черги на наступний елемент;</li>
	<li>Звільнення пам’яті, яку займав перший елемент черги.</li>
	<li></li>
	<li></li>
	<li></li>
</ol>


<p>В
реальних задачах іноді виникає необхідність у формуванні черг, відмінних від
приведених структур. Порядок вибірки елементів з таких черг визначається
пріоритетами елементів. Пріоритет в загальному випадку може бути представлений
числовим значенням, яке обчислюється або на підставі значень яких-небудь полів
елемента, або на підставі зовнішніх чинників. Так попередньо наведені структури
стек і черги можна трактувати як пріоритетні черги, в яких пріоритет елемента
залежить від часу його включення в структуру. При вибірці елемента всякий раз
вибирається елемент з щонайбільшим пріоритетом.</p>

<p>Черги з пріоритетами можуть бути реалізовані на лінійних структурах - в
суміжному або зв’язному представленні. Можливі черги з пріоритетним включенням
- в яких послідовність елементів черги весь час підтримується впорядкованою,
тобто кожний новий елемент включається на те місце в послідовності, яке
визначається його пріоритетом, а при виключенні завжди вибирається елемент з
голови. Можливі і черги з пріоритетним виключенням - новий елемент включається
завжди в кінець черги, а при виключенні в черзі шукається (цей пошук може бути
тільки лінійним) елемент з максимальним пріоритетом і після вибірки вилучається
з послідовності. І в тому, і в іншому варіанті потрібний пошук, а якщо черга
розміщується в статичній пам’яті - ще і переміщення елементів.</p>

<h2>Деки</h2>

<p>Дек -
особливий вид черги. Дек (deq - double ended queue, тобто черга з двома
кінцями) - це такий послідовний список, в якому як включення, так і виключення
елементів, може здійснюватися з будь-якого з двох кінців списку. Так само можна
сформулювати поняття деку, як стек, в якому включення і виключення елементів
може здійснюватися з обох кінців.</p>

<p>Деки
рідко зустрічаються у своєму первісному визначенні. Окремий випадок деку - дек
з обмеженим входом і дек з обмеженим виходом. Логічна і фізична структури деку
аналогічні логічній і фізичній структурі кільцевої черги. Проте, стосовно деку
доцільно говорити не про голову і хвіст, а про лівий і правий кінець.</p>

<p>Над
деком доступні наступні операції:</p>
<ol>
	<li>включення елемента праворуч;</li>
	<li>включення елемента ліворуч;</li>
	<li>виключення елемента з права;</li>
	<li>виключення елемента з ліва;</li>
	<li>визначення розміру;</li>
	<li>очищення.</li>
</ol>


<p>Фізична структура деку в статичній пам’яті ідентична структурі
кільцевої черги.</p>

<h2>Лінійні списки</h2>

<p>Лінійні
списки є узагальненням попередніх структур; вони дозволяють представити множину
так, щоб кожний елемент був доступний і при цьому не потрібно було б зачіпати
деякі інші.</p>

<p>Списки
є досить гнучкою структурою даних, так як їх легко зробити більшими або
меншими, і їх елементи доступні для вставки або вилучення в будь-якій позиції
списку. Списки також можна об’єднувати або розділяти на менші списки.</p>

<p>Лінійний список - це скінчена послідовність однотипних елементів
(вузлів), можливо, з повторенням. Кількість елементів у послідовності
називається довжиною списку. Вона в процесі роботи програми може змінюватися.
Лінійний список <i>L</i>, що складається з елементів <i>d</i>, <i>d</i><sub>2</sub>,•••, <i>d<sub>n</sub></i>, які
мають однаковий тип, записують у вигляді</p>

<img src="fkit_kn_pzs_asd_LEK.files/image004.gif" alt="Подпись: di -► d2 ► d3	dn" v:shapes="Shape_x0020_21" width="211" hspace="12" height="25" align="right">
<p><i>L = { d, d<sub>2</sub>,•••, d</i>„), або зображають графічно.</p>

<p>Важливою
властивістю лінійного списку є те, що його елементи можна лінійно впорядкувати
у відповідності з їх позицією в списку.</p>

<p>Для
формування абстрактного типу даних на основі математичного визначення списку
потрібно задати множину операторів, які виконуються над об’єктами типу список.
Проте не існує однієї множини операторів, які виконуються над списками, які
задовольняють відразу всі можливі застосування.</p>

<p>Найчастіше
зі списками доводиться виконувати такі операції:</p>
<ol>
	<li>Знайти елемент із заданою
властивістю;</li>
	<li>Визначити і-й елемент у лінійному
списку;</li>
	<li>Внести додатковий елемент до або
після вказаного вузла;</li>
	<li>Вилучити певний елемент списку;</li>
	<li>Впорядкувати вузли лінійного
списку в певному порядку.</li>
</ol>

<p>У
реальних мовах програмування не існує якої-небудь структури даних для
зображення лінійного списку так, щоб усі операції над ним виконувалися в
однаковій мірі ефективно. Тому при роботі з лінійними списками важливе значення
має подання лінійних списків, які використовуються в програмі, таким чином, щоб
була забезпечена максимальна ефективність і за часом виконання програми, і за
обсягом потрібної їй пам’яті.</p>

<p>Лінійний
список є послідовність об’єктів. Позиція елемента в списку має інший тип даних,
відмінний від типу даних елемента списку, і цей тип залежить від конкретної
фізичної реалізації.</p>

<p>Над
лінійним списком допустимі наступні операції.</p>

<p>Операція
вставки - вставляє елемент в конкретну позицію в списку, переміщуючи елементи
від цієї позиції і далі в наступну, більш вищу позицію.</p>

<p>Операція
локалізації - повертає позицію об’єкта в списку. Якщо в списку об’єкт
зустрічається декілька разів, то повертається позиція першого від початку
списку об’єкта. Якщо об’єкта немає в списку, то повертається значення, яке
рівне довжині списку, збільшене на одиницю.</p>

<p>Операція
вибірки елемента з списку - повертає елемент, який знаходиться в конкретній
позиції списку. Результат не визначений, якщо в списку немає такої позиції.</p>

<p>Операція
вилучення - вилучає елемент в конкретній позиції зі списку. Результат
невизначений, якщо в списку немає вказаної позиції.</p>

<p>Операції
вибірки попереднього і наступного елемента - повертають відповідно наступній і
попередній елемент списку відносно конкретної позиці в списку.</p>

<p>Функція
очистки списку робить список пустим.</p>

<p>Основні
методи зберігання лінійних списків поділяються на методи послідовного і
зв’язного зберігання. При виборі способу зберігання в конкретній програмі слід
враховувати, які операції і з якою частотою будуть виконуватися над лінійними
списками, вартість їх виконання та обсяг потрібної пам’яті для зберігання списку.</p>

<p>Найпростіша
форма представлення лінійного списку — це вектор. Визначивши таким чином список
можна по чергово звертатися до них в циклі і виконувати необхідні дії. Однак
при такому представленні лінійного списку не вдасться уникнути фізичного
переміщення елементів, якщо потрібно добавляти нові елементи, або вилучати
існуючі. Набагато швидше вилучати елементи можна за допомогою простої схеми
чистки пам’яті. Замість вилучення елементів із списку, їх помічають як
невикористані.</p>

<p>Більш
складною організацією при роботі зі списками є розміщення в масиві декількох
списків або розміщення списку без прив’язки його початку до першого елемента
масиву.</p>

<p>При
зв’язному представленні лінійного списку кожен його елемент складається із
значення і покажчика, який вказує на наступний елемент у списку.</p>

<p>На наступному рисунку приведена структура однозв’язного списку. Кожний
список повинен мати особливий елемент, який називається покажчиком на початок
списку, або головою списку.</p>

<img src="fkit_kn_pzs_asd_LEK.files/image005.gif" alt="Подпись: >■ Inf Next -► Inf Next -► Inf NULL" v:shapes="Shape_x0020_23" width="217" hspace="12" height="20" align="right"><p>Голова списку  ----- </p>

<p>Проте,
обробка однозв’язного списку не завжди зручна, оскільки відсутня можливість
просування в протилежну сторону. Таку можливість забезпечує двох - зв’язний
список, кожний елемент якого містить два покажчики: на наступний і попередній
елементи списку.</p>

<img src="fkit_kn_pzs_asd_LEK.files/image007.jpg" v:shapes="Picutre_x0020_25" width="488" height="58">

<p>Для
зручності обробки списку додають ще один особливий елемент - покажчик кінця
списку. Наявність двох покажчиків в кожному елементі ускладнює список і
приводить до додаткових витрат пам’яті, але в той же час забезпечує більш
ефективне виконання деяких операцій над списком.</p>

<p>Різновидом розглянутих видів лінійних списків є кільцевий список, який
може бути організований на основі як однозв’язного, так і двох-зв’язного
списків. При цьому в однозв’язному списку покажчик останнього елемента повинен
вказувати на перший елемент; в двох-зв’язному списку в першому і останньому
елементах відповідні покажчики змінюються.</p>

<img src="fkit_kn_pzs_asd_LEK.files/image009.jpg" v:shapes="Picutre_x0020_26" width="462" height="81">

<p>При
роботі з такими списками дещо спрощуються деякі процедури, проте, при перегляді
такого списку слід приймати деякі запобіжні засоби, щоб не потрапити в
нескінченний цикл.</p>

<p>В
пам’яті список є сукупністю опису однакових за розміром і форматом структур,
які розміщені довільно в деякій ділянці пам’яті і пов’язані одна з одною в
лінійно впорядкований ланцюжок за допомогою покажчиків. Структура містить
інформаційні поля і поля покажчиків на сусідні елементи списку, причому деякими
полями інформаційної частини можуть бути покажчики на блоки пам’яті з
додатковою інформацією, що відноситься до елемента списку.</p>

<p>Розглянемо
деякі прості операції над лінійними списками.</p>

<p>Вставка елемента в середину однозв’язного списку:</p>

<img src="fkit_kn_pzs_asd_LEK.files/image011.jpg" v:shapes="Picutre_x0020_27" width="436" height="82">

<p>Вставка елемента в двох-зв’язний список:</p>

<img src="fkit_kn_pzs_asd_LEK.files/image013.jpg" v:shapes="Picutre_x0020_28" width="515" height="90">


<p>Наведені приклади забезпечують вставку в середину списку, але не можуть
бути застосовані для вставки на початок списку. При такій операції повинен
модифікуватися покажчик на початок списку:</p>

<img src="fkit_kn_pzs_asd_LEK.files/image015.jpg" v:shapes="Picutre_x0020_29" width="298" height="75">

<p>Видалення елемента з однозв’язного списку для двох варіантів - з
середини і з голови:</p>


<img src="fkit_kn_pzs_asd_LEK.files/image017.jpg" v:shapes="Picutre_x0020_30" width="652" height="51">



 <table cellspacing="0" cellpadding="0" align="left">
  <tbody><tr>
 <td width="36" height="0"></td>
 <td width="77"></td>
 <td width="302"></td>
 <td width="65"></td>
  </tr>
  <tr>
 <td height="21"></td>
 <td valign="top" align="left"><img src="fkit_kn_pzs_asd_LEK.files/image018.gif" alt="Подпись: з середини" v:shapes="Shape_x0020_31" width="77" height="21"></td>
 <td></td>
 <td valign="top" align="left"><img src="fkit_kn_pzs_asd_LEK.files/image019.gif" alt="Подпись: з початку" v:shapes="Shape_x0020_33" width="65" height="21"></td>
  </tr>
 </tbody></table>
 

<p>Видалення елемента з двох-зв’язного списку вимагає корекції більшої
кількості покажчиків:</p>

<img src="fkit_kn_pzs_asd_LEK.files/image021.jpg" v:shapes="Picutre_x0020_35" width="513" height="63">


<p>Процедура
видалення елемента з двох-зв’язного списку виявиться навіть простішою, ніж для
однозв’язного, оскільки в ній не потрібно шукати попередній елемент, він
вибирається за покажчиком назад.</p>

<p>Змінність динамічних структур даних допускає не тільки зміни розміру
структури, але і зміни зв’язків між елементами. Для зв’язних структур зміна
зв’язків не вимагає пересилки даних в пам’яті, а тільки зміни покажчиків в
елементах зв’язної структури. В якості прикладу приведена перестановка двох сусідніх
елементів списку. В алгоритмі перестановки в однозв’язному списку виходили з
того, що відома адреса елемента, який передує парі, в якій проводиться
перестановка. В приведеному алгоритмі також не враховується випадок
перестановки початкових елементів списку.</p>

<img src="fkit_kn_pzs_asd_LEK.files/image023.jpg" v:shapes="Picutre_x0020_36" width="477" height="57">

<p>У процедурі перестановки для двох-зв’язного списку неважко врахувати і
перестановку на початку списку.</p>

<h2>Мультисписки</h2>

<p>В
програмних системах, які обробляють об’єкти складної структури, можуть
вирішуватися різні підзадачі, кожна з яких вимагає обробки можливо не всієї
множини об’єктів, а лише якоїсь його підмножини.</p>

<p>Для
того, щоб при вибірці кожної підмножини не виконувати повний перегляд з
відсіванням записів, які до необхідної підмножини не відносяться, в кожний
запис включаються додаткові поля посилань, кожне з яких зв’язує в лінійний
список елементи відповідної підмножини. В результаті виходить багато-зв’язковий
список або мультисписок, кожний елемент якого може входити одночасно в декілька
однозв’язних списків.</p>

<p>До
переваг мультисписків крім економії пам’яті (при множині списків інформаційна
частина існує в єдиному екземплярі) слід віднести також цілісність даних - в
тому сенсі, що всі підзадачі працюють з однією і тією ж версією інформаційної
частини і зміни в даних, зроблені одній підзадачей негайно стають доступними
для іншої підзадачі.</p>

<p>Кожна підзадача працює з своєю підмножиною як з лінійним списком,
використовуючи для цього певне поле зв’язку. Специфіка мультисписку виявляється
тільки в операції виключення елемента із списку. Виключення елемента з якого-
небудь одного списку ще не означає необхідності видалення елемента з пам’яті,
оскільки елемент може залишатися у складі інших списків. Пам’ять повинна
звільнятися тільки у тому випадку, коли елемент вже не входить ні в один з
приватних списків мультисписку. Звичайно задача видалення спрощується тим, що
один з приватних списків є головним - в нього обов’язково входять всі наявні
елементи. Тоді виключення елемента з будь-якого неголовного списку полягає
тільки в зміні покажчиків, але не в звільненні пам’яті. Виключення ж з
головного списку вимагає не тільки звільнення пам’яті, але і зміні покажчиків
як в головному списку, так і у всіх неголовних списках, в які елемент, що
видаляється, входив.</p>

<h2>Стрічки</h2>

<p>Стрічка
- це лінійно впорядкована послідовність символів, які належать до скінченої
множини символів, яка називається алфавітом.</p>

<p>Стрічки
мають наступні важливі властивості:</p>
<ol>
	<li>їхня довжина, як правило, змінна,
хоч алфавіт фіксований;</li>
	<li>звичайне звернення до символів
стрічки йде з будь-якого одного боку послідовності (важлива впорядкованість
послідовності, а не її індексація);</li>
	<li>метою доступу до стрічки є на
окремий її елемент, а ланцюжок символів.</li>
</ol>

<p>Кажучи
про стрічки, звичайно мають на увазі текстові стрічки - стрічки, що складаються
з символів, які входять в алфавіт якої-небудь вибраної мови, цифр, розділових
знаків і інших службових символів. Текстова стрічка є найбільш універсальною
формою представлення будь-якої інформації.</p>

<p>Хоча
стрічки й розглядаються в частині, яка присвячена напівстатичним структурам
даних, в тих або інших конкретних задачах змінність стрічок може варіюватися
від повної її відсутності до практично необмежених можливостей зміни.
Орієнтація на ту чи іншу міру мінливості стрічок визначає і фізичне
представлення їх в пам’яті і особливості виконання операцій над ними. В
більшості мов програмування стрічки представляються саме як напівстатичні
структури.</p>

<p>Базовими
операціями над стрічками є:</p>
<ol>
	<li>визначення довжини стрічки;</li>
	<li>присвоєння стрічки;</li>
	<li>конкатенація (зчеплення) стрічок;</li>
	<li>виділення підстрічки;</li>
	<li>пошук входження.</li>

</ol>

<p>Операція
визначення довжини стрічки має вид функції, яка повертає значення - ціле число
- поточна кількість символів в стрічці. Операція присвоєння має такий же сенс,
що і для інших типів даних.</p>

<p>Операція
порівняння стрічок має такий же сенс, що і для інших типів даних. Порівняння
стрічок проводиться за наступними правилами. Порівнюються перші символи двох
стрічок. Якщо символи не рівні, то стрічка, що містить символ, місце якого в
алфавіті ближче до початку, вважається меншою. Якщо символи рівні, порівнюються
другі, треті і т.д. символи. При досягненні кінця в одній з стрічок стрічка
меншої довжини вважається меншою. При рівності довжин стрічок і попарній
рівності всіх символів в них стрічки вважаються рівними.</p>

<p>Результатом
операції зчеплення двох стрічок є стрічка, довжина якої рівна сумарній довжині
стрічок-операндів, а значення відповідає значенню першого операнда, за яким
безпосередньо слідує значення другого операнда.</p>

<p>Операція
виділення підстрічки виділяє з початкової стрічки послідовність символів,
починаючи із заданої позиції, із заданою довжиною.</p>

<p>Операція
пошуку входження знаходить місце першого входження підстрічки еталону в
початкову стрічку. Результатом операції може бути номер позиції в початковій
стрічці, з яким починається входження еталону або покажчик на початок
входження. У разі відсутності входження результатом операції повинне бути деяке
спеціальне значення, наприклад, від’ємний номер позиції або порожній покажчик.</p>

<p>Найпростішим
способом є представлення стрічки у вигляді вектора постійної довжини. При цьому
в пам’яті відводиться фіксована кількість байт, в які записуються символи
стрічки. Якщо стрічка менша відведеного під неї вектора, то зайві місця
заповнюються пропусками, а якщо стрічка виходить за межі вектора, то зайві
(праві) символи повинні бути відкинуті.</p>

<p>Можливе
представлення стрічки вектором змінної довжини з ознакою завершення. Цей і всі
подальші за ним методи враховують змінну довжину стрічок. Ознака завершення -
це особливий символ, який належить до алфавіту (таким чином, корисний алфавіт
виявляється меншим на один символ), і займає ту ж кількість розрядів, що і всі
інші символи. Витрати пам’яті при цьому способі складають 1 символ на рядок.</p>

<p>Окрім
ознаки завершення можна використати лічильник символів - це ціле число, і для нього
відводиться достатня кількість бітів, щоб їх з надлишком вистачало для
представлення довжини найдовшої стрічки, яку можна представити. При
використовуванні лічильника символів можливий довільний доступ до символів в
межах стрічки.</p>

<p>Представлення
стрічок списком у пам’яті забезпечує гнучкість у виконанні різноманітних
операцій над ними (зокрема, операцій включення і виключення окремих символів і
цілих ланцюжків) і використовування системних засобів управління пам’яттю при
виділенні необхідного об’єму пам’яті для стрічки. Проте, при цьому виникають
додаткові затрати пам’яті. Іншим недоліком такого представлення стрічок є те,
що логічно сусідні елементи стрічки не є фізично сусідніми в пам’яті. Це
ускладнює доступ до груп елементів стрічки в порівнянні з доступом у векторному
представленні.</p>

<p>При
представленні стрічки однозв’язним лінійним списком кожний символ стрічки
представляється у вигляді елемента зв’язного списку; елемент містить код
символу і покажчик на наступний елемент. Одностороннє зчеплення представляє
доступ тільки в одному напрямі уздовж стрічки.</p>

<p>При
використанні двох-зв’язних лінійних списків у кожний елемент списку додається
також покажчик на попередній елемент. Двостороннє зчеплення допускає
двосторонній рух уздовж списку, що може значно підвищити ефективність виконання
деяких стрічкових операцій.</p>

<p>Блочно-зв’язне представлення стрічок дозволяє в більшості операцій
уникнути витрат, які пов’язані з управлінням динамічною пам’яттю, але в той же
час забезпечує достатньо ефективне використовування пам’яті при роботі з
стрічками змінної довжини.
</p>

	</div>
</body>
</html>