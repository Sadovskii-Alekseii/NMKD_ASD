<!DOCTYPE html>
<html>
<head>
	<title> Лекція № 5</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Лекція № 5</div>
		<h1>Динамічні структури даних. Дерева та графи</h1>

5.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->ДИНАМІЧНІ СТРУКТУРИ ДАНИХ</p>

<p class="24" style="margin-left:0cm;text-align:justify;text-indent:0cm;
mso-pagination:lines-together;page-break-after:avoid;mso-list:l7 level1 lfo9;
tab-stops:53.75pt"><!--[if !supportLists]--><span style="mso-list:Ignore">5.1.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Зв'язне представлення даних в пам'яті</p>

<p>Динамічні структури за визначенням характеризуються відсутністю
фізичної суміжності елементів структури в пам’яті, непостійністю і непередбачуваністю
розміру (кількість елементів) структури в процесі її обробки.</p>

<p>Оскільки
елементи динамічної структури розташовуються за не передбачуваними адресами
пам’яті, адресу елемента такої структури не можна обчислити за адресою
початкового або попереднього елемента. Для встановлення зв’язку між елементами
динамічної структури використовуються покажчики, через які встановлюються явні
зв’язки між елементами. Таке представлення даних в пам’яті називається
зв’язним. Елемент динамічної структури складається з двох полів:</p>

<p class="11" style="margin-left:19.0pt;text-align:justify;text-indent:-19.0pt;
line-height:97%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:97%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->інформаційного поля або поля
даних, в якому містяться ті дані, заради яких і створюється структура;</p>

<p class="11" style="margin-left:19.0pt;text-align:justify;text-indent:-19.0pt;
line-height:97%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:97%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->поле зв’язку, в якому міститься
один або декілька покажчиків, які зв’язують даний елемент з іншими елементами
структури.</p>

<p>Коли
зв’язне представлення даних використовується для вирішення прикладної задачі,
для кінцевого користувача „видимим” робиться тільки вміст інформаційного поля,
а поле зв’язку використовується тільки програмістом- розробником.</p>

<p>Переваги
зв’язного представлення даних:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:92%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:92%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->можливість забезпечення значної
змінності структур;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:92%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:92%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->розмір структури обмежується
тільки доступним об’ємом машинної пам’яті;</p>

<p class="11" style="margin-left:19.0pt;text-align:justify;text-indent:-19.0pt;
line-height:97%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:97%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->при зміні логічної послідовності
елементів структури потрібно виконати не переміщення даних в пам’яті, а тільки
корекцію покажчиків.</p>

<p>Разом з
тим зв’язне представлення не позбавлене й недоліків, основні з яких:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:94%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:94%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->робота з покажчиками вимагає більш
високої кваліфікації від програміста;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:94%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:94%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->на поля зв’язку витрачається
додаткова пам’ять;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:94%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:94%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->доступ до елементів зв’язної
структури може бути менш ефективним за часом.</p>

<p>Останній недолік є найбільш серйозним і саме ним обмежується
застосування зв’язного представлення даних. Якщо в суміжному представленні
даних для обчислення адреси будь-якого елемента у всіх випадках достатньо
номера елемента і інформації, яка міститься в описі структури, то для зв’язного
представлення адреса елемента не може бути обчислена з початкових даних. Опис
зв’язної структури містить один або декілька покажчиків, які дозволяють увійти
до структури, далі пошук необхідного елемента виконується проходженням
ланцюжком покажчиків від елемента до елемента. Тому зв’язне представлення
практично ніколи не застосовується в задачах, де логічна структура даних має
вигляд вектора або масиву - з доступом за номером елемента, але часто
застосовується в задачах, де логічна структура вимагає іншої початкової
інформації доступу (таблиці, списки, дерева і т.д.).</p>

<p class="10" style="margin-top:0cm;margin-right:0cm;margin-bottom:5.0pt;
margin-left:0cm;text-indent:0cm;mso-pagination:lines-together;page-break-after:
avoid;mso-list:l30 level1 lfo8;tab-stops:19.95pt"><!--[if !supportLists]--><span style="mso-list:Ignore">6.<span style="font:7.0pt &quot;Times New Roman&quot;"> <!--[endif]-->НЕЛІНІЙНІ СТРУКТУРИ ДАНИХ</p>

<p class="24" style="margin-top:0cm;margin-right:0cm;margin-bottom:3.0pt;
margin-left:0cm;text-align:justify;text-indent:0cm;mso-pagination:lines-together;
page-break-after:avoid;mso-list:l18 level1 lfo10;tab-stops:53.5pt"><!--[if !supportLists]--><span style="mso-list:Ignore">6.1.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Графи</p>

<p>Граф -
це складна нелінійна багато-зв’язна динамічна структура, що відображає
властивості і зв’язки складного об’єкту.</p>

<p>Ця
багато-зв’язна структура має наступні властивості:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:92%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:92%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->на кожний елемент (вузол, вершину)
може бути довільна кількість посилань;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:92%;mso-list:l4 level1 lfo1;tab-stops:17.25pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:92%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->кожний елемент може мати зв’язок з
будь-якою кількістю інших елементів;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:0cm;
line-height:92%;mso-list:l4 level1 lfo1;tab-stops:17.65pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:92%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->кожний зв’язок (ребро, дуга) може
мати напрям і вагу.</p>

<p>У
вузлах графа міститься інформація про елементи об’єкту. Зв’язки між вузлами
задаються ребрами графа. Ребра графа можуть мати спрямованість, тоді вони
називаються орієнтованими, в іншому випадку - неорієнтовані. Граф, усі зв’язки
якого орієнтовані, називається орієнтованим графом; граф зі всіма
неорієнтованими зв’язками - неорієнтованим графом; граф із зв’язками обох типів
- змішаним графом.</p>

<p>Існує
два основні методи представлення графів в пам’яті комп’ютера: матричний і
зв’язними нелінійними списками. Вибір методу представлення залежить від природи
даних і операцій, що виконуються над ними. Якщо задача вимагає великої
кількості включень і виключень вузлів, то доцільно представляти граф зв’язними
списками; інакше можна застосувати і матричне представлення.</p>

<p>При
використанні матриць суміжності їхні елементи представляються в пам’яті
комп’ютера елементами масиву. При цьому, для простого графа матриця складається
з нулів і одиниць, для мультиграфа - з нулів і цілих чисел, які вказують
кратність відповідних ребер, для зваженого графа - з нулів і дійсних чисел, які
задають вагу кожного ребра.</p>

<p>Орієнтований
граф представляється зв’язним нелінійним списком, якщо він часто змінюється або
якщо півміри входу і виходу його вузлів великі.</p>

<p>Багато-зв’язна структура - граф - знаходить широке застосування при
організації банків даних, управлінні базами даних, в системах програмного
імітаційного моделювання складних комплексів, в системах штучного інтелекту, в
задачах планування і в інших сферах.</p>

<p class="24" style="margin-left:0cm;text-align:justify;text-indent:0cm;
mso-pagination:lines-together;page-break-after:avoid;mso-list:l18 level1 lfo10;
tab-stops:53.5pt"><!--[if !supportLists]--><span style="mso-list:Ignore">6.2.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Дерева</p>

<p>Дерево
- це граф, який характеризується наступними властивостями:</p>

<p class="11" style="margin-left:19.0pt;text-align:justify;text-indent:-19.0pt;
line-height:97%;mso-list:l4 level1 lfo1;tab-stops:17.65pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:97%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Існує єдиний елемент (вузол або
вершина), на який не посилається ніякий інший елемент, - він називається
коренем.</p>

<p class="11" style="margin-left:19.0pt;text-align:justify;text-indent:-19.0pt;
line-height:97%;mso-list:l4 level1 lfo1;tab-stops:17.65pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:97%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Починаючи з кореня і слідуючи по
певному ланцюжку покажчиків, що містяться в елементах, можна здійснити доступ
до будь-якого елемента структури.</p>

<p class="11" style="margin-left:19.0pt;text-align:justify;text-indent:-19.0pt;
line-height:97%;mso-list:l4 level1 lfo1;tab-stops:17.65pt"><!--[if !supportLists]--><span style="font-size:15.0pt;line-height:97%" lang="UK"><span style="mso-list:Ignore">•<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->На кожний елемент, крім кореня, є
єдине посилання, тобто кожний елемент адресується єдиним покажчиком.</p>

<p>Назва
„дерево” виникла з логічної еквівалентності дерево-видної структури
абстрактному дереву з теорії графів. Лінія зв’язку між парою вузлів дерева
називається гілкою. Ті вузли, які не посилаються ні на які інші вузли дерева,
називаються листям. Вузол, що не є листком або коренем, вважається проміжним
або вузлом галуження.</p>

<p>В багатьох застосування відносний порядок проходження вершин на кожному
окремому ярусі має певне значення. При представленні дерева в пам’яті
комп’ютера такий порядок вводиться автоматично, навіть якщо він сам по собі
довільний. Порядок проходження вершин на деякому ярусі можна легко ввести,
позначаючи одну вершину як першу, іншу - як другу і т.д. Замість
впорядковування вершин можна задавати порядок на ребрах. Якщо в орієнтованому
дереві на кожному ярусі заданий порядок проходження вершин, то таке дерево
називається впорядкованим деревом.<br style="mso-special-character:
line-break;page-break-before:always" clear="all">
</p>

<img src="fkit_kn_pzs_asd_LEK.files/image025.jpg" v:shapes="Shape_x0020_37" width="101" hspace="11" height="51" align="right">
<p>Введемо ще деякі поняття, пов’язані з деревами. Вузол X називається
предком, або батьком, а вузли Y і Z називаються нащадками, або синами, їх,
відповідно, між собою називають братами. Причому, лівий син є старшим сином, а
правий - молодшим. Кількість піддерев даної вершини називається мірою цієї
вершини.</p>

<p>Якщо з
дерева прибрати коріння і ребра, що сполучають коріння з вершинами першого
ярусу, то вийде деяка множина незв’язаних дерев. Множина незв’язаних дерев
називається лісом.</p>

<p>Є ряд
способів графічного зображення дерев. Перший спосіб полягає у використовуванні
для зображення піддерев відомого методу діаграм Венна, другий - методу дужок,
що вкладаються одна в одну, третій спосіб - це спосіб, який використовується
при складанні змісту книг. Останній спосіб, що базується на форматі з
нумерацією рівнів, схожий з методами, які використовуються в мовах
програмування. При застосуванні цього формату кожній вершині приписується
числовий номер, який повинен бути менший номерів, приписаних кореневим вершинам
приєднаних до неї піддерев.</p>

<p>Повне
дерево містить максимально можливу кількість вузлів на кожному рівні, крім
нижнього. Повні дерева мають ряд важливих властивостей.</p>

<p>По-перше,
це найкоротші дерева, які можуть містити задану кількість вузлів. Досить
корисна властивість повних дерев полягає в тому, що вони можуть бути дуже
компактно записані в масивах. Якщо пронумерувати вузли в „природному” порядку,
зверху вниз і зліва направо, то можна помістити елементи дерева в масив у цьому
ж порядку.</p>

<p>Існують
<i>m-арні</i> дерева, тобто такі дерева, в яких півміра виходу кожної вершини
менша або рівна <i>т.</i> Якщо півміра виходу кожної вершини в точності рівна
або <i>т,</i> або нулю, то таке дерево називається повним m-арним деревом. При <i>т=2</i>
такі дерева називаються відповідно бінарними, або повними бінарними.</p>

<p>Представити
<i>m</i>-арне дерево в пам’яті комп’ютера складно, так як кожен елемент дерева
повинен містити стільки покажчиків, скільки ребер, виходить з вузла. Це приведе
до підвищеної витрати пам’яті, різноманітності початкових елементів і
ускладнить алгоритми обробки дерева. Тому <i>m</i>-арні дерева, ліс необхідно
привести до бінарних для економії пам’яті і спрощенню алгоритмів. Усі вузли
бінарного дерева представляються в пам’яті однотипними елементами з двома
покажчиками, крім того, операції над бінарними деревами виконуються просто і
ефективно.</p>

<p>Правило
побудови бінарного дерева з будь-якого дерева:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l3 level1 lfo11;tab-stops:50.45pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->В кожному вузлі залишити тільки
гілку до старшого сина;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l3 level1 lfo11;tab-stops:51.9pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->З’єднати горизонтальними ребрами
всіх братів одного батька;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l3 level1 lfo11;tab-stops:51.9pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Таким чином перебудувати дерево за
правилом:</p>

<p>лівий
син - вершина, розташована під даною;</p>

<p>правий
син - вершина, розташована праворуч від даної (тобто на одному ярусі з нею).</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l3 level1 lfo11;tab-stops:51.4pt"><!--[if !supportLists]--><span style="mso-list:Ignore">4.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Розвернути дерево так, щоб усі
вертикальні гілки відображали лівих синів, а горизонтальні - правих.</p>

<p>У
результаті перетворення будь-якого дерева, в бінарне, виходить дерево у вигляді
лівого піддерева, підвішеного до кореня.</p>

<p>У
процесі перетворення правий покажчик кожного вузла бінарного дерева буде
вказувати на сусіда по рівню. Якщо такого немає, то правий покажчик - <b>NULL</b>.
Лівий покажчик буде вказувати на вершину наступного рівня. Якщо такої немає, то
покажчик встановлюється на <b>NULL</b>.</p>

<p>Описаний
вище метод представлення довільних впорядкованих дерев за допомогою бінарних
дерев можна узагальнити на представлення довільного впорядкованого лісу.</p>

<p>Правило
побудови бінарного дерева з лісу: корені всіх піддерев лісу з’єднати
горизонтальними зв’язками. В отриманому дереві вузли в даному прикладі будуть
розташовуватися на трьох рівнях. Далі перебудовувати по раніше розглянутому плану.
В результаті перетворення впорядкованого лісу в бінарне дерево виходить повне
бінарне дерево з лівим і правим піддеревом.</p>

<p>Дерева
можна представляти за допомогою зв’язних списків і масивів (або послідовних
списків).</p>

<p>Частіше
всього використовується зв’язне представлення дерев, так як воно дуже сильно
нагадує логічне. Зв’язне зберігання полягає в тому, що задається зв’язок від
батька до синів. В бінарному дереві є два покажчики, тому зручно вузол
представити у вигляді структури в якій <i>left</i> - покажчик на ліве
піддерево, <i>right</i> - покажчик на праве піддерево, <i>inf -</i> містить
інформацію, яка зв’язана з вершиною і має наперед визначений тип - <i>data.</i></p>

<p>Над
деревами визначені наступні основні операції:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l12 level1 lfo12;tab-stops:54.35pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Пошук вузла із заданим ключем.</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l12 level1 lfo12;tab-stops:55.8pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Додавання нового вузла.</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l12 level1 lfo12;tab-stops:55.8pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Видалення вузла (піддерева).</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l12 level1 lfo12;tab-stops:55.8pt"><!--[if !supportLists]--><span style="mso-list:Ignore">4)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Обхід дерева в певному порядку:</p>

<p>Низхідний
обхід;</p>

<p>Змішаний
обхід;</p>

<p>Висхідний
обхід.</p>

<p>Потрібна
вершина в дереві шукається за ключем. Пошук в бінарному дереві здійснюється
таким чином.</p>

<p>Нехай
побудовано деяке дерево і вимагається знайти вузол з ключем X. Спочатку
порівнюємо з X ключ, що знаходиться в корені дерева. У разі рівності пошук
закінчений і потрібно повернути покажчик на корінь в якості результату пошуку.
Інакше переходимо до розгляду вершини, яка знаходиться зліва внизу, якщо ключ X
менший тільки що розглянутого, або справа внизу, якщо ключ X більший тільки що
розглянутого. Порівнюємо ключ X з ключем, що міститься в цій вершині, і т.д.
Процес завершується в одному з двох випадків:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l10 level1 lfo13;tab-stops:54.35pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->знайдена вершина, що містить ключ,
рівний ключу X;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l10 level1 lfo13;tab-stops:55.1pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->в дереві відсутня вершина, до якої
потрібно перейти для виконання чергового кроку пошуку.</p>

<p>В
першому випадку повертається покажчик на знайдену вершину. В другому - покажчик
на вузол, де зупинився пошук (що зручне для побудови дерева ).</p>

<p>Для
включення запису в дерево перш за все потрібно знайти в дереві ту вершину, до
якої можна приєднати нову вершину, відповідну запису, що включається. При цьому
впорядкованість ключів повинна зберігатися.</p>

<p>Алгоритм
пошуку потрібної вершини, взагалі кажучи, той же самий, що і при пошуку вершини
із заданим ключем. Ця вершина буде знайдена в той момент, коли в якості
чергового покажчика, який визначає гілку дерева, в якій треба продовжити пошук,
виявиться покажчик <b>NULL</b>.</p>

<p>В
багатьох задачах, пов’язаних з деревами, вимагається здійснити систематичний
перегляд всіх його вузлів в певному порядку. Такий перегляд називається
проходженням або обходом дерева.</p>

<p>Бінарне
дерево можна обходити трьома основними способами: низхідним, змішаним і
висхідним (можливі також зворотний низхідний, зворотний змішаний і зворотний
висхідний обходи). Прийняті назви методів обходу зв’язані з часом обробки
кореневої вершини: До того як оброблено обидва його піддерева, після того, як
оброблено ліве піддерево, але до того як оброблено праве, після того, як
оброблено обидва піддерева. Використовувані назви методів відображають напрям
обходу в дереві: від кореневої вершини вниз до листя - низхідний обхід; від
листя вгору до кореня - висхідний обхід, і змішаний обхід - від найлівішого
листка дерева через корінь до найправішого листка.</p>

<p>Схемно
алгоритм обходу бінарного дерева відповідно до низхідного способу може
виглядати таким чином:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l16 level1 lfo14;tab-stops:52.65pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->В якості чергової вершини взяти
корінь дерева. Перейти до пункту 2.</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l16 level1 lfo14;tab-stops:53.6pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Провести обробку чергової вершини
відповідно до вимог задачі. Перейти до пункту 3.</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l16 level1 lfo14;tab-stops:53.85pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->а) Якщо чергова вершина має обидві
гілки, то в якості нової вершини вибрати ту вершину, на яку посилається ліва
гілка, а вершину, на яку посилається права гілка, занести в стек; перейти до
пункту 2;</p>

<p>3.б)
якщо чергова вершина є кінцевою, то вибрати в якості нової чергової вершини
вершину із стека, якщо він не порожній, і перейти до пункту 2; якщо ж стек
порожній, то це означає, що обхід всього дерева закінчений, перейти до пункту <i>4;</i></p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l21 level1 lfo2;tab-stops:53.6pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->в) якщо чергова вершина має тільки
одну гілку, то в якості чергової вершини вибрати ту вершину, на яку ця гілка
вказує, перейти до пункту 2.</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l21 level1 lfo2;tab-stops:54.1pt"><!--[if !supportLists]--><span style="mso-list:Ignore">4.<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Кінець алгоритму.</p>

<p>Алгоритм
істотно спрощується при використовуванні рекурсії. Так, низхідний обхід можна
описати таким чином:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l11 level1 lfo15;tab-stops:54.8pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->. Обробка кореневої вершини;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l11 level1 lfo15;tab-stops:56.25pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->. Низхідний обхід лівого піддерева;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l11 level1 lfo15;tab-stops:56.25pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->. Низхідний обхід правого
піддерева.</p>

<p>Змішаний
обхід можна описати таким чином:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l19 level1 lfo16;tab-stops:54.8pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Спуститися по лівій гілці із
запам’ятовуванням вершин в стеку;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l19 level1 lfo16;tab-stops:56.25pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Якщо стек порожній те перейти до
п.5;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l19 level1 lfo16;tab-stops:56.25pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Вибрати вершину із стеку і
обробити дані вершини;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l19 level1 lfo16;tab-stops:56.25pt"><!--[if !supportLists]--><span style="mso-list:Ignore">4)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Якщо вершина має правого сина, то
перейти до нього; перейти до п.1.</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l19 level1 lfo16;tab-stops:56.25pt"><!--[if !supportLists]--><span style="mso-list:Ignore">5)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Кінець алгоритму.</p>

<p>Рекурсивний
змішаний обхід описується таким чином:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l25 level1 lfo17;tab-stops:55.85pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Змішаний обхід лівого піддерева;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l25 level1 lfo17;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Обробка кореневої вершини;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l25 level1 lfo17;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Змішаний обхід правого піддерева.</p>

<p>Трудність
реалізації висхідного обходу полягає в тому, що на відміну від попереднього
методу в цьому алгоритмі кожна вершина запам’ятовується в стеку двічі: вперше -
коли обходиться ліве піддерево, і другий раз - коли обходиться праве піддерево.
Таким чином, в алгоритмі необхідно розрізняти два види стекових записів: 1-й
означає, що в даний момент обходиться ліве піддерево; 2-й - що обходиться
праве, тому в стеку запам’ятовується покажчик на вузол і ознаку (код-1 і код-2
відповідно).</p>

<p>Алгоритм
висхідного обходу можна представити таким чином:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l23 level1 lfo18;tab-stops:56.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Спуститися по лівій гілці із
запам’ятовуванням вершини в стеку як 1-й вид стекових записів;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l23 level1 lfo18;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Якщо стек порожній, то перейти до
п.5;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l23 level1 lfo18;tab-stops:57.05pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Вибрати вершину із стека, якщо це
перший вид стекових записів, то повернути його в стек як 2-й вид стекових
записів; перейти до правого сина; перейти до п.1, інакше перейти до п.4;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l23 level1 lfo18;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">4)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Обробити дані вершини і перейти до
п.2;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l23 level1 lfo18;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">5)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->Кінець алгоритму.</p>

<p>Рекурсивний
змішаний обхід описується таким чином:</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l9 level1 lfo19;tab-stops:55.85pt"><!--[if !supportLists]--><span style="mso-list:Ignore">1)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->. Висхідний обхід лівого
піддерева;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l9 level1 lfo19;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">2)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->. Висхідний обхід правого
піддерева;</p>

<p class="11" style="margin-left:0cm;text-align:justify;text-indent:36.0pt;
mso-list:l9 level1 lfo19;tab-stops:57.3pt"><!--[if !supportLists]--><span style="mso-list:Ignore">3)<span style="font:7.0pt &quot;Times New Roman&quot;">
<!--[endif]-->. Обробка кореневої вершини.</p>

<p>Якщо в розглянутих вище алгоритмах поміняти місцями поля покажчики на
лівого і правого сина, то отримують процедури зворотного низхідного, зворотного
змішаного і зворотного висхідного обходів.
</p>
	</div>
</body>
</html>